#ifndef ADAPTIVE_PARALLEL_TEMPERING_H
#define ADAPTIVE_PARALLEL_TEMPERING_H

#include "tsp_problem.h"
#include "solution.h"

#include <iostream>
#include <vector>
#include <functional>
#include <random>
#include <omp.h>
#include <chrono>
#include <memory>
#include <atomic>
#include <mutex>
#include <string>
#include <fstream>

// Define a Logger class for better logging
class Logger {
public:
    enum LogLevel { DEBUG, INFO, WARNING, ERROR };
    
    Logger(LogLevel level = INFO, const std::string& logFile = "") : level(level) {
        if (!logFile.empty()) {
            fileStream.open(logFile, std::ios::out);
        }
    }
    
    ~Logger() {
        if (fileStream.is_open()) {
            fileStream.close();
        }
    }
    
    template<typename... Args>
    void debug(const char* format, Args... args) {
        if (level <= DEBUG) log(DEBUG, format, args...);
    }
    
    template<typename... Args>
    void info(const char* format, Args... args) {
        if (level <= INFO) log(INFO, format, args...);
    }
    
    template<typename... Args>
    void warning(const char* format, Args... args) {
        if (level <= WARNING) log(WARNING, format, args...);
    }
    
    template<typename... Args>
    void error(const char* format, Args... args) {
        if (level <= ERROR) log(ERROR, format, args...);
    }

private:
    LogLevel level;
    std::ofstream fileStream;
    std::mutex logMutex;
    
    const char* levelToString(LogLevel l) {
        switch (l) {
            case DEBUG: return "DEBUG";
            case INFO: return "INFO";
            case WARNING: return "WARNING";
            case ERROR: return "ERROR";
            default: return "UNKNOWN";
        }
    }
    
    template<typename... Args>
    void log(LogLevel msgLevel, const char* format, Args... args) {
        char buffer[1024];
        if constexpr(sizeof...(args) > 0){
            snprintf(buffer, sizeof(buffer), format, args...);
        } else{
            snprintf(buffer, sizeof(buffer), "%s", format);
        }
        
        auto now = std::chrono::system_clock::now();
        auto now_time = std::chrono::system_clock::to_time_t(now);
        
        std::lock_guard<std::mutex> lock(logMutex);
        std::string timestamp = std::ctime(&now_time);
        timestamp.pop_back(); // Remove newline
        
        std::string message = "[" + timestamp + "] [" + levelToString(msgLevel) + "] " + buffer + "\n";
        
        std::cout << message;
        if (fileStream.is_open()) {
            fileStream << message;
            fileStream.flush();
        }
    }
};

// Timer class for performance measurements
class Timer {
public:
    Timer() : start(std::chrono::high_resolution_clock::now()) {}
    
    double elapsed() {
        auto now = std::chrono::high_resolution_clock::now();
        return std::chrono::duration<double>(now - start).count();
    }
    
    void reset() {
        start = std::chrono::high_resolution_clock::now();
    }
    
private:
    std::chrono::time_point<std::chrono::high_resolution_clock> start;
};

// Statistics tracking
struct PerformanceStats {
    double totalTime = 0.0;
    double mcmcTime = 0.0;
    double swapTime = 0.0;
    double adaptTime = 0.0;
    
    void reset() {
        totalTime = mcmcTime = swapTime = adaptTime = 0.0;
    }
};

class AdaptiveParallelTempering {
public:
    // Constructor with parameters for adaptive tempering
    AdaptiveParallelTempering(const TSPProblem& problem, 
                      int initialReplicas = 16,     // Start with more replicas than needed
                      double minTemp = 0.1,
                      double maxTemp = 100.0,
                      int swapInterval = 100,
                      int maxIterations = 10000,
                      double targetSAP = 0.23,       // Target swap acceptance probability
                      double initialAlpha = 0.1,    // Initial damping factor
                      double t0 = 100.0,            // Time constant for damping decay
                      const std::string& logFile = "apt_log.txt");

    // Run the adaptive parallel tempering algorithm
    Solution solve();

    // Getters
    std::vector<Solution> getReplicas() const;
    std::vector<double> getTemperatures() const;
    std::vector<double> getSAPs() const;
    PerformanceStats getPerformanceStats() const { return stats; }
    
    // Setters
    void setNumThreads(int threads) { numThreads = threads; }
    void setLogLevel(Logger::LogLevel level) { logger.reset(new Logger(level, logFile)); }

private:
    // TSP problem instance
    const TSPProblem& problem;
    
    // Replicas (solutions at different temperatures)
    std::vector<Solution> replicas;
    
    // Temperature ladder
    std::vector<double> temperatures;
    
    // Statistics for adaptive algorithm
    std::vector<std::shared_ptr<std::atomic<int>>> acceptedSwaps;    // Thread-safe counters
    std::vector<std::shared_ptr<std::atomic<int>>> attemptedSwaps;
    std::vector<double> swapAcceptanceProbabilities; // SAPs between adjacent temperatures
    
    // Algorithm parameters
    int numReplicas;
    int numThreads;
    double minTemp;
    double maxTemp;
    int swapInterval;     // N_swap in the paper
    int maxIterations;
    
    // Adaptive parameters
    double targetSAP;     // Target swap acceptance probability
    double alpha;         // Current damping factor
    double alpha0;        // Initial damping factor
    double t0;            // Time constant for damping decay
    std::atomic<int> totalSwapAttempts; // t in equation (5)
    double thresholdDrop;  // Threshold for dropping replicas
    double thresholdInsert; // Threshold for inserting replicas
    
    // Best solution tracking
    Solution bestSolutionFound;
    std::atomic<double> bestCostFound;
    std::mutex bestSolutionMutex;
    
    // Random generators (thread-local)
    mutable std::mutex rngMutex;
    std::vector<std::mt19937> rngPool;
    
    // Logging
    std::string logFile;
    std::unique_ptr<Logger> logger;
    
    // Performance tracking
    Timer totalTimer;
    PerformanceStats stats;
    
    // Initialize temperature ladder (geometric progression)
    void initializeTemperatures();
    
    // Initialize replicas with random solutions
    void initializeReplicas();
    
    // Perform a Metropolis step at a given temperature
    void metropolisStep(Solution& solution, double temperature, int replicaIndex);
    
    // Get a thread-safe RNG
    std::mt19937& getRNG(int threadId);
    
    // Attempt to swap configurations between adjacent temperatures
    void attemptSwaps();
    
    // Calculate the acceptance probability for replica exchange
    double calculateSwapAcceptance(const Solution& replica1, const Solution& replica2, 
                                  double temp1, double temp2);
    
    // Adjust temperatures to achieve uniform SAP (Algorithm 1)
    void adjustTemperatures();
    
    // Manage replica insertion/removal
    void manageReplicas();
    
    // Update damping factor according to equation (5)
    void updateDampingFactor();
    
    // Update SAP statistics
    void updateSAPs();
    
    // Update best solution
    void updateBestSolution(const Solution& solution);
    
    // Display progress
    void displayProgress(int iteration);
    
    // Handle thread-safe access to vectors
    template<typename T>
    T& getThreadSafe(std::vector<T>& vec, int index) {
        while (index >= vec.size()) {
            std::unique_lock<std::mutex> lock(rngMutex, std::try_to_lock);
            if (lock.owns_lock() && index >= vec.size()) {
                vec.resize(index + 1);
            }
        }
        return vec[index];
    }
};

#endif // ADAPTIVE_PARALLEL_TEMPERING_H