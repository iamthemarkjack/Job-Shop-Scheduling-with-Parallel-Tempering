#include "improved_adap.h"

#include <cmath>
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <thread>
#include <mutex>
#include <condition_variable>

// Implementation of AdaptiveParallelTempering

AdaptiveParallelTempering::AdaptiveParallelTempering(const TSPProblem& problem, 
                                              int initialReplicas,
                                              double minTemp,
                                              double maxTemp,
                                              int swapInterval,
                                              int maxIterations,
                                              double targetSAP,
                                              double initialAlpha,
                                              double t0,
                                              const std::string& logFile)
    : problem(problem), 
      numReplicas(initialReplicas),
      minTemp(minTemp),
      maxTemp(maxTemp),
      swapInterval(swapInterval),
      maxIterations(maxIterations),
      targetSAP(targetSAP),
      alpha(initialAlpha),
      alpha0(initialAlpha),
      t0(t0),
      totalSwapAttempts(0),
      thresholdDrop(0.05),
      thresholdInsert(0.05),
      bestCostFound(std::numeric_limits<double>::max()),
      logFile(logFile) {
    
    // Set default number of threads to hardware concurrency or numReplicas, whichever is smaller
    numThreads = std::min(static_cast<int>(std::thread::hardware_concurrency()), numReplicas);
    
    // Initialize logger
    logger.reset(new Logger(Logger::INFO, logFile));
    
    // Initialize RNG pool (one per thread)
    unsigned seed = std::random_device{}();
    for (int i = 0; i < numThreads; ++i) {
        rngPool.emplace_back(seed + i);  // Different seed for each thread
    }
    
    // Initialize vectors with appropriate sizes
    acceptedSwaps.resize(numReplicas - 1);
    attemptedSwaps.resize(numReplicas - 1);
    
    for (int i = 0; i < numReplicas - 1; ++i) {
        acceptedSwaps[i] = 0;
        attemptedSwaps[i] = 0;
    }
    
    swapAcceptanceProbabilities.resize(numReplicas - 1, 0.0);
    
    // Initialize temperatures and replicas
    initializeTemperatures();
    initializeReplicas();
    
    // Initialize best solution
    bestSolutionFound = replicas[0];
    bestCostFound = bestSolutionFound.getCost();
    
    logger->info("Initialized AdaptiveParallelTempering with %d replicas, %d threads", numReplicas, numThreads);
    logger->info("Temperature range: [%.2f, %.2f], Target SAP: %.2f", minTemp, maxTemp, targetSAP);
}

void AdaptiveParallelTempering::initializeTemperatures() {
    temperatures.resize(numReplicas);
    
    // Geometric progression from minTemp to maxTemp
    double ratio = std::pow(maxTemp / minTemp, 1.0 / (numReplicas - 1));
    
    for (int i = 0; i < numReplicas; i++) {
        temperatures[i] = minTemp * std::pow(ratio, i);
    }
    
    std::ostringstream oss;
    oss << "Temperature ladder initialized: ";
    for (int i = 0; i < std::min(5, numReplicas); i++) {
        oss << temperatures[i] << " ";
    }
    if (numReplicas > 5) oss << "... " << temperatures.back();
    
    logger->info("%s", oss.str().c_str());
}

void AdaptiveParallelTempering::initializeReplicas() {
    replicas.resize(numReplicas);
    
    // Create random initial solutions for each replica
    for (int i = 0; i < numReplicas; ++i) {
        replicas[i] = Solution(problem);
        // Use the thread ID modulo rngPool size to ensure we don't go out of bounds
        int rngIndex = i % rngPool.size();
        replicas[i].randomize(rngPool[rngIndex]);
    }
    
    logger->info("Replicas initialized with random solutions");
}

std::mt19937& AdaptiveParallelTempering::getRNG(int threadId) {
    // Ensure thread-safe access to RNG pool
    std::lock_guard<std::mutex> lock(rngMutex);
    
    // If threadId is out of range, resize the RNG pool
    if (threadId >= rngPool.size()) {
        unsigned seed = std::random_device{}();
        rngPool.resize(threadId + 1);
        for (size_t i = rngPool.size() - 1; i <= threadId; ++i) {
            rngPool[i].seed(seed + i);
        }
    }
    
    return rngPool[threadId];
}

void AdaptiveParallelTempering::metropolisStep(Solution& solution, double temperature, int replicaIndex) {
    // Get thread ID for this call
    int threadId = omp_get_thread_num();
    
    // Create a candidate solution by applying a random move
    Solution candidate = solution;
    
    // Apply a random move (e.g., 2-opt, insertion, etc.)
    candidate.applyRandomMove(getRNG(threadId));
    
    // Calculate the cost difference
    double currentCost = solution.getCost();
    double candidateCost = candidate.getCost();
    double delta = candidateCost - currentCost;
    
    // Accept or reject the move based on Metropolis criterion
    if (delta <= 0) {
        // Always accept if the new solution is better
        solution = candidate;
        
        // Update the best solution if this is better
        if (candidateCost < bestCostFound) {
            updateBestSolution(candidate);
        }
    } else {
        // Accept with probability exp(-delta/T) if the new solution is worse
        std::uniform_real_distribution<double> dist(0.0, 1.0);
        if (dist(getRNG(threadId)) < std::exp(-delta / temperature)) {
            solution = candidate;
        }
    }
}

void AdaptiveParallelTempering::updateBestSolution(const Solution& solution) {
    double cost = solution.getCost();
    double current = bestCostFound.load();
    
    // Try to update the atomic cost first to avoid unnecessary lock contention
    while (cost < current) {
        if (bestCostFound.compare_exchange_weak(current, cost)) {
            // If we successfully updated the cost, also update the solution
            std::lock_guard<std::mutex> lock(bestSolutionMutex);
            bestSolutionFound = solution;
            logger->info("New best solution found: %.2f", cost);
            break;
        }
        // If compare_exchange failed, current now contains the latest value
        current = bestCostFound.load();
    }
}

double AdaptiveParallelTempering::calculateSwapAcceptance(const Solution& replica1, const Solution& replica2, 
    double temp1, double temp2) {
    // Calculate the energy (cost) difference
    double energy1 = replica1.getCost();
    double energy2 = replica2.getCost();

    // Calculate the Metropolis criterion for replica exchange
    double deltaE = (1.0 / temp1 - 1.0 / temp2) * (energy1 - energy2);

    // Return the acceptance probability
    return std::min(1.0, std::exp(deltaE));
}

void AdaptiveParallelTempering::attemptSwaps() {
    Timer swapTimer;
    
    // Use a single random number generator for all swaps
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    std::mt19937 rng(seed);
    std::uniform_real_distribution<double> dist(0.0, 1.0);
    
    // Swap only between adjacent temperatures
    for (int i = 0; i < numReplicas - 1; i++) {
        totalSwapAttempts++;
        attemptedSwaps[i]->fetch_add(1, std::memory_order_relaxed);
        
        double acceptProb = calculateSwapAcceptance(
            replicas[i], replicas[i+1], 
            temperatures[i], temperatures[i+1]
        );
        
        if (dist(rng) < acceptProb) {
            // Accept swap
            std::swap(replicas[i], replicas[i+1]);
            acceptedSwaps[i]->fetch_add(1, std::memory_order_relaxed);
        }
    }
    
    stats.swapTime += swapTimer.elapsed();
}

void AdaptiveParallelTempering::updateSAPs() {
    // Update swap acceptance probabilities
    for (int i = 0; i < numReplicas - 1; i++) {
        if (attemptedSwaps[i] > 0) {
            swapAcceptanceProbabilities[i] = static_cast<double>(acceptedSwaps[i]->load(std::memory_order_relaxed)) / 
                                  attemptedSwaps[i]->load(std::memory_order_relaxed);
        }
    }
    
    // Log SAPs periodically
    std::ostringstream oss;
    oss << "SAPs: ";
    for (int i = 0; i < std::min(5, (int)swapAcceptanceProbabilities.size()); i++) {
        oss << std::fixed << std::setprecision(2) << swapAcceptanceProbabilities[i] << " ";
    }
    if (swapAcceptanceProbabilities.size() > 5) 
        oss << "... " << swapAcceptanceProbabilities.back();
    
    logger->debug("%s", oss.str().c_str());
}

void AdaptiveParallelTempering::updateDampingFactor() {
    // Update damping factor according to equation (5)
    alpha = alpha0 * (t0 / (t0 + totalSwapAttempts));
    logger->debug("Updated damping factor: %.6f", alpha);
}

void AdaptiveParallelTempering::adjustTemperatures() {
    Timer adaptTimer;
    
    // Implement Algorithm 1 from the paper
    std::vector<double> newTemperatures = temperatures;
    
    for (int i = 0; i < numReplicas - 1; i++) {
        // Calculate gap between actual SAP and target SAP
        double gap = swapAcceptanceProbabilities[i] - targetSAP;
        
        if (gap > 0) {
            // SAP is too high, increase temperature difference
            double deltaT = (temperatures[i+1] - temperatures[i]) * alpha;
            newTemperatures[i+1] += deltaT;
        } else if (gap < 0) {
            // SAP is too low, decrease temperature difference
            double deltaT = (temperatures[i+1] - temperatures[i]) * alpha;
            newTemperatures[i+1] -= deltaT;
        }
    }
    
    // Update temperatures
    temperatures = newTemperatures;
    
    std::ostringstream oss;
    oss << "Adjusted temperatures: ";
    for (int i = 0; i < std::min(5, numReplicas); i++) {
        oss << std::fixed << std::setprecision(2) << temperatures[i] << " ";
    }
    if (numReplicas > 5) oss << "... " << temperatures.back();
    
    logger->debug("%s", oss.str().c_str());
    
    stats.adaptTime += adaptTimer.elapsed();
}

void AdaptiveParallelTempering::manageReplicas() {
    // Check if we need to drop or insert replicas
    
    // If numReplicas < 2, we can't perform any more operations
    if (numReplicas < 2) return;
    
    // Get SAP between the two highest temperatures
    double highestSAP = swapAcceptanceProbabilities[numReplicas - 2];
    
    if (highestSAP > targetSAP + thresholdDrop) {
        // Drop the highest temperature replica
        temperatures.pop_back();
        replicas.pop_back();
        
        // We need to resize the atomic vectors safely
        while (acceptedSwaps.size() > numReplicas - 1) {
            acceptedSwaps.pop_back();
        }
        while (attemptedSwaps.size() > numReplicas - 1) {
            attemptedSwaps.pop_back();
        }
        
        while (swapAcceptanceProbabilities.size() > numReplicas - 1) {
            swapAcceptanceProbabilities.pop_back();
        }
        
        numReplicas--;
        
        logger->info("Dropped replica. New count: %d", numReplicas);
    } 
    else if (highestSAP < targetSAP - thresholdInsert) {
        // Insert new replica between two highest temperatures
        double newTemp = 0.5 * (temperatures[numReplicas-1] + temperatures[numReplicas-2]);
        temperatures.push_back(newTemp);
        
        // Create new replica by cloning the second highest one
        replicas.push_back(replicas[numReplicas-2]);
        
        // Initialize statistics for the new pair
        while (acceptedSwaps.size() < numReplicas) {
            acceptedSwaps.push_back(0);
        }
        while (attemptedSwaps.size() < numReplicas) {
            attemptedSwaps.push_back(0);
        }
        while (swapAcceptanceProbabilities.size() < numReplicas) {
            swapAcceptanceProbabilities.push_back(0.0);
        }
        
        numReplicas++;
        
        logger->info("Inserted replica. New count: %d", numReplicas);
    }
}

void AdaptiveParallelTempering::displayProgress(int iteration) {
    double progress = 100.0 * iteration / maxIterations;
    int barWidth = 50;
    int pos = barWidth * progress / 100.0;
    
    std::ostringstream progressBar;
    progressBar << "[";
    for (int i = 0; i < barWidth; ++i) {
        if (i < pos) progressBar << "=";
        else if (i == pos) progressBar << ">";
        else progressBar << " ";
    }
    progressBar << "] " << std::fixed << std::setprecision(1) << progress << "%";
    
    // Calculate ETA
    double elapsed = totalTimer.elapsed();
    double eta = elapsed / iteration * (maxIterations - iteration);
    
    // Format ETA
    int etaH = static_cast<int>(eta / 3600);
    int etaM = static_cast<int>((eta - etaH * 3600) / 60);
    int etaS = static_cast<int>(eta - etaH * 3600 - etaM * 60);
    
    std::ostringstream etaStr;
    if (etaH > 0) etaStr << etaH << "h ";
    if (etaM > 0 || etaH > 0) etaStr << etaM << "m ";
    etaStr << etaS << "s";
    
    logger->info("Iteration %d/%d %s ETA: %s, Best: %.2f", 
                iteration, maxIterations, progressBar.str().c_str(), 
                etaStr.str().c_str(), bestCostFound.load());
}

std::vector<Solution> AdaptiveParallelTempering::getReplicas() const {
    std::vector<Solution> result;
    result.reserve(replicas.size());
    
    for (const auto& replica : replicas) {
        result.push_back(replica);
    }
    
    return result;
}

std::vector<double> AdaptiveParallelTempering::getTemperatures() const {
    return temperatures;
}

std::vector<double> AdaptiveParallelTempering::getSAPs() const {
    return swapAcceptanceProbabilities;
}

Solution AdaptiveParallelTempering::solve() {
    // Reset timers and stats
    totalTimer.reset();
    stats.reset();
    
    // Set the number of OpenMP threads
    omp_set_num_threads(numThreads);
    
    logger->info("Starting optimization with %d threads, %d replicas", numThreads, numReplicas);

    // Main algorithm loop
    int iteration = 0;
    
    while (iteration < maxIterations) {
        Timer mcmcTimer;
        
        // Run MCMC steps for each replica in parallel
        #pragma omp parallel for schedule(dynamic)
        for (int i = 0; i < numReplicas; i++) {
            // For each iteration, perform multiple Metropolis steps
            // to ensure good mixing at that temperature
            for (int step = 0; step < 100; step++) {
                metropolisStep(replicas[i], temperatures[i], i);
            }
        }
        
        stats.mcmcTime += mcmcTimer.elapsed();
        
        // Attempt swaps between adjacent temperatures
        #pragma omp critical
        {
            attemptSwaps();
        }
        
        // Every N_swap iterations, adjust temperatures and manage replicas
        if (iteration % swapInterval == 0 && iteration > 0) {
            Timer adaptTimer;
            
            updateSAPs();
            updateDampingFactor();
            adjustTemperatures();
            manageReplicas();
            
            stats.adaptTime += adaptTimer.elapsed();
        }

        // Display progress periodically
        if (iteration % (maxIterations / 100) == 0 || iteration == maxIterations - 1) {
            displayProgress(iteration);
        }
        
        iteration++;
    }
    
    stats.totalTime = totalTimer.elapsed();
    
    // Log final performance statistics
    logger->info("Optimization completed in %.2f seconds", stats.totalTime);
    logger->info("Time breakdown - MCMC: %.2f s (%.1f%%), Swaps: %.2f s (%.1f%%), Adaptation: %.2f s (%.1f%%)",
               stats.mcmcTime, 100.0 * stats.mcmcTime / stats.totalTime,
               stats.swapTime, 100.0 * stats.swapTime / stats.totalTime,
               stats.adaptTime, 100.0 * stats.adaptTime / stats.totalTime);
    
    // Return the best solution found during the entire run
    logger->info("Best solution: %.2f", bestCostFound.load());
    
    return bestSolutionFound;
}